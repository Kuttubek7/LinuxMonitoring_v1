# Bash-скрипты: начало

В первой строке нам нужно указать, какую оболочку мы собираемся использовать. Нас интересует bash, поэтому первая строка файла будет такой:
```shell
#!/bin/bash
```

Другие строки в этом файле используют решетку для обозначения комментариев, которые оболочка не обрабатывает. Однако первая строка представляет собой особый случай: за решеткой следует восклицательный знак (эта последовательность называется шебангом).

Команды оболочки разделяются символом новой строки. Вот как это выглядит:
```shell
#!/bin/bash
# This is a comment
pwd
whoami
```

Чтобы запустить скрипт, вам нужно дать скрипту разрешение на выполнение. Для этого запустите в терминале эту команду:
```shell
chmod +x ./myscript
```

Теперь скрипт можно запустить, введя в командной строке:
```shell
./myscript
```

### Текстовый вывод

Команда echo используется для вывода текста в консоль Linux:
```shell
echo "Hello World"
```

### Переменные

В сценариях bash можно использовать два типа переменных:
- Переменные среды
- Пользовательские переменные

Переменные среды хранят некоторые системные данные, такие как домашний каталог текущего пользователя:
```shell
echo "Home for the current user is: $HOME"
```

Также bash-скрипты позволяют вам устанавливать и использовать в скрипте свои собственные переменные. Такие переменные сохраняют значение до тех пор, пока сценарий не завершится.

Как и системные переменные, к пользовательским переменным можно получить доступ с помощью знака доллара:
```shell
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

### Подстановка команд

Скрипт bash позволяет получать информацию из вывода команды и назначать ее переменным.

Есть два способа сделать это:

- Использование обратного апострофа "`".
- Использование конструкции $()

Таким образом, сохранение вывода команды pwd в переменную mydir может выглядеть так:
```shell
mydir=`pwd`
mydir=$(pwd)
```

### Математические операции

Вы можете использовать $((*operation*)) для выполнения математических операций в файле скрипта:
```shell
var1=$(( 5 + 5 ))
var2=$(( $var1 * 2 ))
```

### Условное заявление

Условный оператор в bash реализован следующим образом:
```shell
if command
then
commands
elif command
then
commands
else
commands
fi
```

Вот пример использования условного оператора:
```
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
else
echo "The user $user doesn’t exist"
fi
```

### Сравнение

Числовые значения можно сравнивать в сценариях. Вот список соответствующих команд:
- n1 -eq n2 -- Возвращает истинное значение, если n1 равно n2.
- n1 -ge n2 -- Возвращает истинное значение, если n1 больше или равно n2.
- n1 -gt n2 -- Возвращает истинное значение, если n1 больше n2.
- n1 -le n2 -- Возвращает истинное значение, если n1 меньше или равно n2.
- n1 -lt n2 -- Возвращает истинное значение, если n1 меньше n2.
- n1 -ne n2 -- Возвращает истинное значение, если n1 не равно n2.

Строковые значения также можно сравнивать в сценариях. Вот список операторов:
- str1 = str2 -- Проверяет строки на равенство, возвращает true, если строки идентичны.
- str1 != str2 -- Возвращает true, если строки не идентичны.
- str1 < str2 -- Возвращает true, если str1 меньше, чем str2.
- str1 > str2 -- Возвращает true, если str1 больше, чем str2.
  -n str1 -- Возвращает true, если длина строки str1 больше нуля.
  -z str1 -- Возвращает true, если длина строки str1 равна нулю.

Пример выполнения операций сравнения:
```
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

Операции сравнения строк имеют определенные особенности:

1. Операторы ">" и "<" должны быть экранированы обратной косой чертой, иначе скрипт будет работать некорректно, хотя сообщений об ошибках не будет. Сценарий интерпретирует «>» как команду вывода перенаправления.

2. Чтобы скрипт работал без предупреждений, переменные, значения которых содержат более одного слова, следует заключать в двойные кавычки:
 
```
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

3. В командах сравнения прописные буквы меньше, чем строчные, потому что сравнение строк выполняется путем сравнения кодов символов ASCII.

### Проверка файлов

Следующие команды позволяют проверить различные состояния файла:
- -d file -- Проверяет, существует ли файл и является ли он каталогом.
- -e file -- Проверяет, существует ли файл.
- -f file -- Проверяет, существует ли файл и является ли он файлом.
- -r file -- Проверяет, существует ли файл и доступен ли он для чтения.
- -s file -- Проверяет, существует ли файл и не является ли он пустым.
- -w file -- Проверяет, существует ли файл и доступен ли он для записи.
- -x file -- Проверяет, существует ли файл и является ли он исполняемым.
- -file1 -nt file2 -- Проверяет, является ли файл1 новее, чем файл2.
- -file1 -ot file2 -- Проверяет, старше ли файл1, чем файл2.
- -O file -- Проверяет, существует ли файл и принадлежит ли он текущему пользователю.
- -G file -- Проверяет, существует ли файл и совпадает ли идентификатор его группы с идентификатором группы текущего пользователя.

В качестве примера, вот скрипт, который выводит содержимое существующего каталога:
```
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi
```