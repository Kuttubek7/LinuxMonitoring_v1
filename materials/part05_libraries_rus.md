# Bash-скрипты, часть 5: функции и создание библиотек

Оболочка bash предоставляет возможность создавать функции. Функция в bash может быть определена двумя способами:
```shell
functionName {
}

functionName1() {
}
```

Чтобы вызвать функцию в сценарии, все, что вам нужно сделать, это указать ее имя.
```shell
function myfunc {
echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "End of the script"
```

Результат описанного выше скрипта:
```
Это пример использования функции
Это пример использования функции
Это пример использования функции
Конец сценария
```

Обратите внимание, что если вы попытаетесь использовать функцию до ее определения, вы получите ошибку.

### Использование команды возврата

Команда return позволяет указать целочисленный код завершения, возвращаемый функцией. Что возвращает функция в $? переменная.

Если вы выполните любую другую команду перед получением значения, возвращаемого функцией, из $? переменная, это значение будет потеряно. Дело в том, что в этой переменной хранится код возврата последней выполненной команды.

Обратите внимание, что максимальное число, которое может вернуть команда return, равно 255. Если функция должна вернуть большее число или строку, ей потребуется другой подход.

Пример работы команды return:
```shell
function myfunc {
read -p "Enter a value: " value
echo "adding value"
return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"
```

### Запись вывода функции в переменную

Другой способ вернуть результаты функции — записать данные, выдаваемые функцией, в переменную. Такой подход позволяет обойти ограничения команды return и вернуть любые данные из функции.

Пример использования этого подхода:
```shell
function myfunc {
read -p "Enter a value: " value
echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
```

### Аргументы функции

Аргументы функций в bash работают так же, как и параметры командной строки, передаваемые сценарию.

Например, имя функции хранится в параметре $0, первый аргумент передается ей в $1 и так далее. Количество переданных функции аргументов хранится в переменной $#.

Пример использования аргументов функции:
```shell
function addnum {
if [ $# -eq 0 ] || [ $# -gt 2 ]
then
echo -1
elif [ $# -eq 1 ]
then
echo $(( $1 + $1 ))
else
echo $(( $1 + $2 ))
fi
}
echo -n "Adding 10 and 15: "
value=$(addnum 10 15)
echo $value
echo -n "Adding one number: "
value=$(addnum 10)
echo $value
echo -n "Adding no numbers: "
value=$(addnum)
echo $value
echo -n "Adding three numbers: "
value=$(addnum 10 15 20)
echo $value
```

Обратите внимание, что функция не может напрямую работать с параметрами, которые передаются скрипту при его запуске из командной строки.

Передача массива в функцию в качестве аргумента не сработает. Вот пример неправильного подхода:
```shell
myarray=(1 2 3 4 5)
echo "The original array is: ${myarray[*]}"
myfunc $myarray
```

Вместо этого вы должны передавать все элементы массива как отдельные аргументы. Пример правильного подхода:
```shell
function myfunc {
newarray=("$@")
echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}
```

### Глобальные и локальные переменные

Принцип работы глобальных и локальных переменных в сценариях bash такой же, как и в других языках программирования.

Единственное отличие состоит в том, что все переменные в скрипте bash по умолчанию считаются глобальными.
Чтобы создать локальную переменную, добавьте слово local перед ее именем:
```shell
local temp=$(( $value + 5 ))
```

### Создание и использование библиотек

Чтобы использовать в скрипте функции, описанные в другом файле, используйте команду source или оператор «точка».

Пример подключения функции из другого файла:

Содержимое файла myfuncs, представляющего собой библиотеку:
```shell
function addnum {
echo $(( $1 + $2 ))
}
```

основной сценарий:
```shell
. ./myfuncs
result=$(addnum 10 20)
echo "The result is: $result"
```