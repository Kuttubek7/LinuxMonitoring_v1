# Bash-скрипты, часть 3: параметры и ключи командной строки

Наиболее распространенный способ передачи данных в скрипты — использование параметров командной строки. Это выглядит так:
```shell
$ ./myscript 10 20
```

Оболочка bash присваивает специальные переменные, называемые параметрами позиции, параметрам командной строки, введенным при вызове скрипта:
- $0 - имя скрипта.
- $1 - первый параметр.
- $2 - второй параметр.
- ...
- $9 - девятый параметр.
- ${10} - десятый параметр.

Вот как вы можете использовать параметры командной строки в скрипте, используя эти переменные:
```shell
echo $0
echo ${11}
```

Обратите внимание, что параметры командной строки разделяются пробелами. Если параметр содержит пробелы, он должен быть заключен в кавычки.

### Проверка параметров

Чтобы проверить, передаются ли параметры скрипту при его вызове, можно сделать следующее:
```shell
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
```

### Подсчет параметров

Переменная $# содержит количество параметров, передаваемых сценарию при вызове.

Эта переменная предоставляет необычный способ получить последние параметры, переданные сценарию, без необходимости знать количество параметров. Вот как это выглядит:
```shell
echo The last parameter was ${!#}
```

### Захват всех параметров командной строки

В некоторых случаях может потребоваться захват всех параметров, передаваемых сценарию. Для этого можно использовать переменные $* и $@.

Переменная $* содержит все параметры, введенные через командную строку, как один элемент.

Переменная $@ содержит все параметры, введенные через командную строку, в виде массива. Вы можете использовать эту переменную для циклического перебора параметров.

### команда сдвига

Команда shift по умолчанию сдвигает значения параметров позиции влево. Например, значение переменной $3 становится значением переменной $2, значение $2 становится значением $1, а то, что было раньше в $1, теряется. Обратите внимание, что значение переменной $0, содержащей имя скрипта, не меняется.

С помощью команды shift рассмотрим еще один способ перебора параметров, передаваемых скрипту:
```shell
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
```

### Параметры командной строки

Параметры командной строки обычно выглядят как буквы, перед которыми стоит тире.
Они используются для управления скриптами. Вот пример:
```shell
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
```

Запустите скрипт:
```shell
$ ./myscript –a –b –c –d
```

Вывод скрипта в терминале:
```shell
Found the -a option
Found the -b option
Found the -c option
-d is not an option
```

Этот код использует конструкцию case, которая проверяет переданный ему параметр по списку параметров, обрабатываемых сценарием.
Если переданное значение найдено в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта используется какая-либо опция, будет выполнена ветвь "*".

### Как отличить опции от параметров

Обычно при написании сценариев bash используются как параметры, так и параметры командной строки. Типичный способ сделать это — использовать специальную последовательность символов, которая сообщает сценарию, когда заканчиваются параметры и начинаются параметры.

Эта последовательность представляет собой двойное тире. Оболочка использует его для указания позиции, на которой заканчивается список ключей. Давайте посмотрим на пример:
```shell
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option";;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

Этот скрипт использует команду break для прерывания цикла while, когда в строке обнаруживается двойной дефис.

Как видите, когда скрипт, разбирая переданные ему данные, находит двойной тире, он заканчивает обработку опции и обрабатывает все, что еще не обработано, как параметры.

### Опции обработки со значениями

По мере усложнения ваших сценариев вы будете сталкиваться с ситуациями, когда обычных параметров уже недостаточно, а это означает, что вам придется использовать параметры с некоторыми значениями.
Например, вызов скрипта, использующего такую возможность, выглядит так:
```shell
./myscript -a test1 -b -c test2
```

Сценарий должен уметь определять, когда наряду с параметрами командной строки используются дополнительные параметры.
Вот пример обработки опции, которой нужен параметр:
```shell
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
```

### Использование стандартных опций

При написании bash-скриптов вы можете выбрать любые буквы для опций командной строки и случайным образом установить реакцию скрипта на эти опции. Однако в мире Linux значения некоторых опций стали чем-то вроде стандарта, которому полезно следовать. Вот список этих опций:
--a -- Список всех элементов.
--c -- Получить количество элементов.
--d -- Выходной каталог.
--e -- Развернуть элементы.
--f -- Указать файл, из которого нужно прочитать данные.
--h -- вывести справку по команде.
--i -- Игнорировать регистр символов.
--l -- Выполнить полноформатный вывод данных.
--n -- Использовать неинтерактивный (пакетный) режим.
--o -- Позволяет указать файл, в который следует перенаправить вывод.
--q -- Выполнить скрипт в тихом режиме.
--r -- Рекурсивно обрабатывать папки и файлы.
--s -- Выполнить скрипт в тихом режиме.
--v -- Выполнить подробный вывод.
--x -- Исключить элемент.
- -y -- Ответьте «да» на все вопросы.

### Получение данных от пользователя

Оболочка bash имеет команду чтения для пользовательского ввода во время выполнения. После получения данных эта команда сохраняет их в переменной:
```shell
echo -n "Enter your name: "
read name
```

Обратите внимание, что команда echo, которая выводит приглашение, вызывается с параметром -n. Это приводит к тому, что в конце подсказки не отображается символ разрыва строки, что позволяет пользователю сценария вводить данные там, где находится подсказка, а не на следующей строке.

Вы можете указать несколько входов:
```shell
read -p "Enter your name: " first last
```

Если вы не укажете переменные для команды чтения, все входящие данные будут сохранены в переменной REPLY.